<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OverlayView.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">com.fitquest.app.ui.coachutils</a> &gt; <span class="el_source">OverlayView.kt</span></div><h1>OverlayView.kt</h1><pre class="source lang-java linenums">package com.fitquest.app.ui.coachutils

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.util.AttributeSet
import android.view.View
import androidx.core.content.ContextCompat
import com.fitquest.app.R
import com.google.mediapipe.tasks.vision.core.RunningMode
import com.google.mediapipe.tasks.vision.poselandmarker.PoseLandmarker
import com.google.mediapipe.tasks.vision.poselandmarker.PoseLandmarkerResult
import kotlin.math.acos
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sqrt

/**
 * OverlayView
 *
 * - PoseLandmarker가 준 landmark 좌표를 기반으로
 *   점/선(스켈레톤)과 관절 각도(예: 팔꿈치, 무릎)를 캔버스에 오버레이한다.
 */
<span class="fc" id="L25">class OverlayView(context: Context, attrs: AttributeSet?) : View(context, attrs) {</span>

    private var results: PoseLandmarkerResult? = null
<span class="fc" id="L28">    private var pointPaint = Paint()</span>
<span class="fc" id="L29">    private var linePaint = Paint()</span>

<span class="fc" id="L31">    private var scaleFactor: Float = 1f</span>
<span class="fc" id="L32">    private var imageWidth: Int = 1</span>
<span class="fc" id="L33">    private var imageHeight: Int = 1</span>

    private var offsetX = 0f
    private var offsetY = 0f

<span class="fc" id="L38">    init {</span>
<span class="fc" id="L39">        initPaints()</span>
<span class="fc" id="L40">    }</span>

    fun clear() {
<span class="fc" id="L43">        results = null</span>
<span class="fc" id="L44">        pointPaint.reset()</span>
<span class="fc" id="L45">        linePaint.reset()</span>
<span class="fc" id="L46">        invalidate()</span>
<span class="fc" id="L47">        initPaints()</span>
<span class="fc" id="L48">    }</span>

    private fun initPaints() {
<span class="fc" id="L51">        linePaint.color = ContextCompat.getColor(context, R.color.mp_color_primary)</span>
<span class="fc" id="L52">        linePaint.strokeWidth = LANDMARK_STROKE_WIDTH</span>
<span class="fc" id="L53">        linePaint.style = Paint.Style.STROKE</span>

<span class="fc" id="L55">        pointPaint.color = Color.YELLOW</span>
<span class="fc" id="L56">        pointPaint.strokeWidth = LANDMARK_STROKE_WIDTH</span>
<span class="fc" id="L57">        pointPaint.style = Paint.Style.FILL</span>
<span class="fc" id="L58">    }</span>

    override fun draw(canvas: Canvas) {
<span class="fc" id="L61">        super.draw(canvas)</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        val poseLandmarkerResult = results ?: return</span>

        // 1) 포인트(관절)와 스켈레톤 라인
<span class="fc bfc" id="L65" title="All 2 branches covered.">        for (landmarkList in poseLandmarkerResult.landmarks()) {</span>
            // draw keypoints
<span class="fc bfc" id="L67" title="All 2 branches covered.">            for (lm in landmarkList) {</span>
<span class="fc" id="L68">                canvas.drawPoint(</span>
<span class="fc" id="L69">                    lm.x() * imageWidth * scaleFactor + offsetX,</span>
<span class="fc" id="L70">                    lm.y() * imageHeight * scaleFactor + offsetY,</span>
<span class="fc" id="L71">                    pointPaint</span>
                )
            }

            // connect keypoints using MediaPipe's skeleton topology
<span class="fc" id="L76">            PoseLandmarker.POSE_LANDMARKS.forEach { connection -&gt;</span>
<span class="fc" id="L77">                canvas.drawLine(</span>
<span class="fc" id="L78">                    landmarkList[connection!!.start()].x() * imageWidth * scaleFactor + offsetX,</span>
<span class="fc" id="L79">                    landmarkList[connection.start()].y() * imageHeight * scaleFactor + offsetY,</span>
<span class="fc" id="L80">                    landmarkList[connection.end()].x() * imageWidth * scaleFactor + offsetX,</span>
<span class="fc" id="L81">                    landmarkList[connection.end()].y() * imageHeight * scaleFactor + offsetY,</span>
<span class="fc" id="L82">                    linePaint</span>
                )
<span class="fc" id="L84">            }</span>
        }

        // 2) 각도 계산용 주요 관절들
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        val landmarks = poseLandmarkerResult.landmarks().getOrNull(0) ?: return</span>

<span class="fc" id="L90">        val lShoulder = landmarks[11]; val rShoulder = landmarks[12]</span>
<span class="fc" id="L91">        val lElbow    = landmarks[13]; val rElbow    = landmarks[14]</span>
<span class="fc" id="L92">        val lWrist    = landmarks[15]; val rWrist    = landmarks[16]</span>

<span class="fc" id="L94">        val lHip      = landmarks[23]; val rHip      = landmarks[24]</span>
<span class="fc" id="L95">        val lKnee     = landmarks[25]; val rKnee     = landmarks[26]</span>
<span class="fc" id="L96">        val lAnkle    = landmarks[27]; val rAnkle    = landmarks[28]</span>

        fun mid(
            a: com.google.mediapipe.tasks.components.containers.NormalizedLandmark,
            b: com.google.mediapipe.tasks.components.containers.NormalizedLandmark
<span class="fc" id="L101">        ) = floatArrayOf((a.x() + b.x()) / 2f, (a.y() + b.y()) / 2f, (a.z() + b.z()) / 2f)</span>

<span class="fc" id="L103">        val shoulderMid = mid(lShoulder, rShoulder)</span>
<span class="fc" id="L104">        val hipMid = mid(lHip, rHip)</span>
<span class="fc" id="L105">        val kneeMid = mid(lKnee, rKnee) // currently unused but kept for possible core angle calc</span>

        // 3) 간단한 2D 각도(팔꿈치, 무릎, 몸통 굴곡 등)
<span class="fc" id="L108">        val leftElbowAngle = calculateAngle2D(</span>
<span class="fc" id="L109">            lShoulder.x(), lShoulder.y(),</span>
<span class="fc" id="L110">            lElbow.x(), lElbow.y(),</span>
<span class="fc" id="L111">            lWrist.x(), lWrist.y()</span>
        )
<span class="fc" id="L113">        val rightElbowAngle = calculateAngle2D(</span>
<span class="fc" id="L114">            rShoulder.x(), rShoulder.y(),</span>
<span class="fc" id="L115">            rElbow.x(), rElbow.y(),</span>
<span class="fc" id="L116">            rWrist.x(), rWrist.y()</span>
        )
<span class="fc" id="L118">        val leftKneeAngle = calculateAngle2D(</span>
<span class="fc" id="L119">            lHip.x(), lHip.y(),</span>
<span class="fc" id="L120">            lKnee.x(), lKnee.y(),</span>
<span class="fc" id="L121">            lAnkle.x(), lAnkle.y()</span>
        )
<span class="fc" id="L123">        val rightKneeAngle = calculateAngle2D(</span>
<span class="fc" id="L124">            rHip.x(), rHip.y(),</span>
<span class="fc" id="L125">            rKnee.x(), rKnee.y(),</span>
<span class="fc" id="L126">            rAnkle.x(), rAnkle.y()</span>
        )
<span class="fc" id="L128">        val flexAngle = calculateAngle2D(</span>
<span class="fc" id="L129">            shoulderMid[0], shoulderMid[1],</span>
<span class="fc" id="L130">            hipMid[0], hipMid[1],</span>
<span class="fc" id="L131">            kneeMid[0], kneeMid[1]</span>
        )

        // 4) 텍스트 스타일
<span class="fc" id="L135">        val textPaint = Paint().apply {</span>
<span class="fc" id="L136">            color = Color.WHITE</span>
<span class="fc" id="L137">            textSize = 40f</span>
<span class="fc" id="L138">            style = Paint.Style.FILL</span>
<span class="fc" id="L139">            isAntiAlias = true</span>
<span class="fc" id="L140">        }</span>

        fun Canvas.drawAngleAtPivot(
            p: com.google.mediapipe.tasks.components.containers.NormalizedLandmark,
            text: String
        ) {
<span class="fc" id="L146">            drawText(</span>
<span class="fc" id="L147">                text,</span>
<span class="fc" id="L148">                p.x() * imageWidth * scaleFactor + offsetX,</span>
<span class="fc" id="L149">                p.y() * imageHeight * scaleFactor + offsetY - 20f,</span>
<span class="fc" id="L150">                textPaint</span>
            )
<span class="fc" id="L152">        }</span>

        // 팔꿈치/무릎 각도 라벨
<span class="fc" id="L155">        canvas.drawAngleAtPivot(lElbow,  &quot;${leftElbowAngle.toInt()}°&quot;)</span>
<span class="fc" id="L156">        canvas.drawAngleAtPivot(rElbow,  &quot;${rightElbowAngle.toInt()}°&quot;)</span>
<span class="fc" id="L157">        canvas.drawAngleAtPivot(lKnee,   &quot;${leftKneeAngle.toInt()}°&quot;)</span>
<span class="fc" id="L158">        canvas.drawAngleAtPivot(rKnee,   &quot;${rightKneeAngle.toInt()}°&quot;)</span>

        // 코어 굴곡(Flex) 각도 라벨
<span class="fc" id="L161">        canvas.drawText(</span>
<span class="fc" id="L162">            &quot;Flex: ${flexAngle.toInt()}°&quot;,</span>
<span class="fc" id="L163">            hipMid[0] * imageWidth * scaleFactor + offsetX,</span>
<span class="fc" id="L164">            hipMid[1] * imageHeight * scaleFactor + offsetY - 60f,</span>
<span class="fc" id="L165">            textPaint</span>
        )
<span class="fc" id="L167">    }</span>

    /**
     * Fragment에서 pose 결과 받을 때마다 호출해주는 함수.
     * 이미지 사이즈/스케일 정보를 저장하고 invalidate()로 다시 그리게 한다.
     */
<span class="nc" id="L173">    fun setResults(</span>
        poseLandmarkerResults: PoseLandmarkerResult,
        imageHeight: Int,
        imageWidth: Int,
<span class="nc" id="L177">        runningMode: RunningMode = RunningMode.IMAGE</span>
    ) {
<span class="fc" id="L179">        results = poseLandmarkerResults</span>

<span class="fc" id="L181">        this.imageHeight = imageHeight</span>
<span class="fc" id="L182">        this.imageWidth = imageWidth</span>

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        scaleFactor = when (runningMode) {</span>
            RunningMode.IMAGE,
            RunningMode.VIDEO -&gt; {
<span class="nc" id="L187">                min(width * 1f / imageWidth, height * 1f / imageHeight)</span>
            }
            RunningMode.LIVE_STREAM -&gt; {
                // 프리뷰는 화면을 채우기 때문에 max로 맞추고 중앙 offset
<span class="fc" id="L191">                max(width * 1f / imageWidth, height * 1f / imageHeight)</span>
            }
        }

<span class="fc" id="L195">        offsetX = (width - imageWidth * scaleFactor) / 2f</span>
<span class="fc" id="L196">        offsetY = (height - imageHeight * scaleFactor) / 2f</span>

<span class="fc" id="L198">        invalidate()</span>
<span class="fc" id="L199">    }</span>

    companion object {
        private const val LANDMARK_STROKE_WIDTH = 12F
    }

    private fun calculateAngle2D(
        ax: Float, ay: Float,
        bx: Float, by: Float,   // pivot (각도의 꼭짓점)
        cx: Float, cy: Float
    ): Double {
<span class="fc" id="L210">        val v1x = ax - bx; val v1y = ay - by</span>
<span class="fc" id="L211">        val v2x = cx - bx; val v2y = cy - by</span>
<span class="fc" id="L212">        val dot = (v1x * v2x + v1y * v2y).toDouble()</span>

<span class="fc" id="L214">        val n1 = sqrt((v1x * v1x + v1y * v1y).toDouble()).coerceAtLeast(1e-8)</span>
<span class="fc" id="L215">        val n2 = sqrt((v2x * v2x + v2y * v2y).toDouble()).coerceAtLeast(1e-8)</span>

<span class="fc" id="L217">        val cosT = (dot / (n1 * n2)).coerceIn(-1.0, 1.0)</span>
<span class="fc" id="L218">        return Math.toDegrees(acos(cosT))</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>